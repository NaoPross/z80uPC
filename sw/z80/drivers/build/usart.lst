                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.6.0 #9615 (Linux)
                              4 ;--------------------------------------------------------
                              5 	.module usart
                              6 	.optsdcc -mz80
                              7 	
                              8 ;--------------------------------------------------------
                              9 ; Public variables in this module
                             10 ;--------------------------------------------------------
                             11 	.globl _usart_word_length
                             12 	.globl _usart_set_baudrate
                             13 	.globl _usart_set_parity
                             14 	.globl _usart_set_stop_bits
                             15 	.globl _usart_set_autoflow
                             16 	.globl _usart_init
                             17 	.globl _usart_transmit
                             18 	.globl _usart_receive
                             19 	.globl _usart_write
                             20 	.globl _usart_read
                             21 ;--------------------------------------------------------
                             22 ; special function registers
                             23 ;--------------------------------------------------------
                             24 ;--------------------------------------------------------
                             25 ; ram data
                             26 ;--------------------------------------------------------
                             27 	.area _DATA
                             28 ;--------------------------------------------------------
                             29 ; ram data
                             30 ;--------------------------------------------------------
                             31 	.area _INITIALIZED
   0000                      32 __usart:
   0000                      33 	.ds 2
                             34 ;--------------------------------------------------------
                             35 ; absolute external ram data
                             36 ;--------------------------------------------------------
                             37 	.area _DABS (ABS)
                             38 ;--------------------------------------------------------
                             39 ; global & static initialisations
                             40 ;--------------------------------------------------------
                             41 	.area _HOME
                             42 	.area _GSINIT
                             43 	.area _GSFINAL
                             44 	.area _GSINIT
                             45 ;--------------------------------------------------------
                             46 ; Home
                             47 ;--------------------------------------------------------
                             48 	.area _HOME
                             49 	.area _HOME
                             50 ;--------------------------------------------------------
                             51 ; code
                             52 ;--------------------------------------------------------
                             53 	.area _CODE
                             54 ;usart.c:5: void usart_set_baudrate(uint16_t baudrate)
                             55 ;	---------------------------------
                             56 ; Function usart_set_baudrate
                             57 ; ---------------------------------
   0000                      58 _usart_set_baudrate::
   0000 DD E5         [15]   59 	push	ix
   0002 DD 21 00 00   [14]   60 	ld	ix,#0
   0006 DD 39         [15]   61 	add	ix,sp
                             62 ;usart.c:8: _usart->LCR.divisor_latch_access = 1;
   0008 2Ar00r00      [16]   63 	ld	hl,(__usart)
   000B 01 04 00      [10]   64 	ld	bc,#0x0004
   000E 09            [11]   65 	add	hl,bc
   000F 7E            [ 7]   66 	ld	a,(hl)
   0010 F6 80         [ 7]   67 	or	a,#0x80
   0012 77            [ 7]   68 	ld	(hl),a
                             69 ;usart.c:9: _usart->buffer = 0x00FF & baudrate; // LSBs
   0013 2Ar00r00      [16]   70 	ld	hl,(__usart)
   0016 DD 4E 04      [19]   71 	ld	c,4 (ix)
   0019 71            [ 7]   72 	ld	(hl),c
                             73 ;usart.c:10: memcpy(&_usart->IER, &(baudrate >>8), 1);
   001A ED 5Br00r00   [20]   74 	ld	de,(__usart)
   001E 13            [ 6]   75 	inc	de
   001F DD 6E 05      [19]   76 	ld	l,5 (ix)
   0022 26 00         [ 7]   77 	ld	h,#0x00
   0024 7E            [ 7]   78 	ld	a, (hl)
   0025 12            [ 7]   79 	ld	(de), a
                             80 ;usart.c:12: _usart->LCR.divisor_latch_access = 0;
   0026 2Ar00r00      [16]   81 	ld	hl,(__usart)
   0029 01 04 00      [10]   82 	ld	bc,#0x0004
   002C 09            [11]   83 	add	hl,bc
   002D 7E            [ 7]   84 	ld	a,(hl)
   002E E6 7F         [ 7]   85 	and	a,#0x7f
   0030 77            [ 7]   86 	ld	(hl),a
   0031 DD E1         [14]   87 	pop	ix
   0033 C9            [10]   88 	ret
                             89 ;usart.c:15: void usart_set_parity(int mode)
                             90 ;	---------------------------------
                             91 ; Function usart_set_parity
                             92 ; ---------------------------------
   0034                      93 _usart_set_parity::
                             94 ;usart.c:18: _usart->LCR.even_parity = 1;
   0034 2Ar00r00      [16]   95 	ld	hl,(__usart)
   0037 01 04 00      [10]   96 	ld	bc,#0x0004
   003A 09            [11]   97 	add	hl,bc
                             98 ;usart.c:17: if (mode == USART_PARITY_EVEN) {
   003B FD 21 02 00   [14]   99 	ld	iy,#2
   003F FD 39         [15]  100 	add	iy,sp
   0041 FD 7E 00      [19]  101 	ld	a,0 (iy)
   0044 3D            [ 4]  102 	dec	a
   0045 20 0C         [12]  103 	jr	NZ,00104$
   0047 FD 7E 01      [19]  104 	ld	a,1 (iy)
   004A B7            [ 4]  105 	or	a, a
   004B 20 06         [12]  106 	jr	NZ,00104$
                            107 ;usart.c:18: _usart->LCR.even_parity = 1;
   004D 7E            [ 7]  108 	ld	a,(hl)
   004E F6 10         [ 7]  109 	or	a,#0x10
   0050 77            [ 7]  110 	ld	(hl),a
   0051 18 17         [12]  111 	jr	00105$
   0053                     112 00104$:
                            113 ;usart.c:20: else if (mode == USART_PARITY_ODD) {
   0053 FD 21 02 00   [14]  114 	ld	iy,#2
   0057 FD 39         [15]  115 	add	iy,sp
   0059 FD 7E 00      [19]  116 	ld	a,0 (iy)
   005C D6 02         [ 7]  117 	sub	a, #0x02
   005E 20 0A         [12]  118 	jr	NZ,00105$
   0060 FD 7E 01      [19]  119 	ld	a,1 (iy)
   0063 B7            [ 4]  120 	or	a, a
   0064 20 04         [12]  121 	jr	NZ,00105$
                            122 ;usart.c:21: _usart->LCR.even_parity = 0;
   0066 7E            [ 7]  123 	ld	a,(hl)
   0067 E6 EF         [ 7]  124 	and	a,#0xef
   0069 77            [ 7]  125 	ld	(hl),a
   006A                     126 00105$:
                            127 ;usart.c:24: _usart->LCR.parity = (mode == USART_PARITY_NONE) ? 0 : 1;
   006A 2Ar00r00      [16]  128 	ld	hl,(__usart)
   006D 01 04 00      [10]  129 	ld	bc,#0x0004
   0070 09            [11]  130 	add	hl,bc
   0071 FD 21 02 00   [14]  131 	ld	iy,#2
   0075 FD 39         [15]  132 	add	iy,sp
   0077 FD 7E 00      [19]  133 	ld	a,0 (iy)
   007A 07            [ 4]  134 	rlca
   007B 07            [ 4]  135 	rlca
   007C 07            [ 4]  136 	rlca
   007D E6 F8         [ 7]  137 	and	a,#0xf8
   007F E6 08         [ 7]  138 	and	a,#0x08
   0081 4F            [ 4]  139 	ld	c,a
   0082 7E            [ 7]  140 	ld	a,(hl)
   0083 E6 F7         [ 7]  141 	and	a,#0xf7
   0085 B1            [ 4]  142 	or	a,c
   0086 77            [ 7]  143 	ld	(hl),a
   0087 C9            [10]  144 	ret
                            145 ;usart.c:27: void usart_set_stop_bits(int count)
                            146 ;	---------------------------------
                            147 ; Function usart_set_stop_bits
                            148 ; ---------------------------------
   0088                     149 _usart_set_stop_bits::
                            150 ;usart.c:29: _usart->LCR.stop_bits = (count == USART_STOP_BITS_1) ? 0 : 1;
   0088 ED 4Br00r00   [20]  151 	ld	bc,(__usart)
   008C 03            [ 6]  152 	inc	bc
   008D 03            [ 6]  153 	inc	bc
   008E 03            [ 6]  154 	inc	bc
   008F 03            [ 6]  155 	inc	bc
   0090 FD 21 02 00   [14]  156 	ld	iy,#2
   0094 FD 39         [15]  157 	add	iy,sp
   0096 FD 7E 00      [19]  158 	ld	a,0 (iy)
   0099 D6 0A         [ 7]  159 	sub	a, #0x0a
   009B 20 0A         [12]  160 	jr	NZ,00103$
   009D FD 7E 01      [19]  161 	ld	a,1 (iy)
   00A0 B7            [ 4]  162 	or	a, a
   00A1 20 04         [12]  163 	jr	NZ,00103$
   00A3 3E 01         [ 7]  164 	ld	a,#0x01
   00A5 18 01         [12]  165 	jr	00104$
   00A7                     166 00103$:
   00A7 AF            [ 4]  167 	xor	a,a
   00A8                     168 00104$:
   00A8 EE 01         [ 7]  169 	xor	a, #0x01
   00AA 87            [ 4]  170 	add	a, a
   00AB 87            [ 4]  171 	add	a, a
   00AC E6 04         [ 7]  172 	and	a,#0x04
   00AE 6F            [ 4]  173 	ld	l,a
   00AF 0A            [ 7]  174 	ld	a,(bc)
   00B0 E6 FB         [ 7]  175 	and	a,#0xfb
   00B2 B5            [ 4]  176 	or	a,l
   00B3 02            [ 7]  177 	ld	(bc),a
   00B4 C9            [10]  178 	ret
                            179 ;usart.c:32: void usart_word_length(int length)
                            180 ;	---------------------------------
                            181 ; Function usart_word_length
                            182 ; ---------------------------------
   00B5                     183 _usart_word_length::
                            184 ;usart.c:34: _usart->LCR.word_length = length;
   00B5 2Ar00r00      [16]  185 	ld	hl,(__usart)
   00B8 01 04 00      [10]  186 	ld	bc,#0x0004
   00BB 09            [11]  187 	add	hl,bc
   00BC FD 21 02 00   [14]  188 	ld	iy,#2
   00C0 FD 39         [15]  189 	add	iy,sp
   00C2 FD 7E 00      [19]  190 	ld	a,0 (iy)
   00C5 E6 03         [ 7]  191 	and	a,#0x03
   00C7 4F            [ 4]  192 	ld	c,a
   00C8 7E            [ 7]  193 	ld	a,(hl)
   00C9 E6 FC         [ 7]  194 	and	a,#0xfc
   00CB B1            [ 4]  195 	or	a,c
   00CC 77            [ 7]  196 	ld	(hl),a
   00CD C9            [10]  197 	ret
                            198 ;usart.c:37: void usart_set_autoflow(int mode)
                            199 ;	---------------------------------
                            200 ; Function usart_set_autoflow
                            201 ; ---------------------------------
   00CE                     202 _usart_set_autoflow::
                            203 ;usart.c:39: _usart->MCR.autoflow = (mode == USART_AUTOFLOW_OFF) ? 0 : 1;
   00CE 2Ar00r00      [16]  204 	ld	hl,(__usart)
   00D1 01 0C 00      [10]  205 	ld	bc,#0x000c
   00D4 09            [11]  206 	add	hl,bc
   00D5 FD 21 02 00   [14]  207 	ld	iy,#2
   00D9 FD 39         [15]  208 	add	iy,sp
   00DB FD 7E 00      [19]  209 	ld	a,0 (iy)
   00DE E6 01         [ 7]  210 	and	a,#0x01
   00E0 4F            [ 4]  211 	ld	c,a
   00E1 7E            [ 7]  212 	ld	a,(hl)
   00E2 E6 FE         [ 7]  213 	and	a,#0xfe
   00E4 B1            [ 4]  214 	or	a,c
   00E5 77            [ 7]  215 	ld	(hl),a
                            216 ;usart.c:40: _usart->MCR.data_terminal_ready = (mode == USART_AUTOFLOW_ALL);
   00E6 2Ar00r00      [16]  217 	ld	hl,(__usart)
   00E9 01 05 00      [10]  218 	ld	bc,#0x0005
   00EC 09            [11]  219 	add	hl,bc
   00ED FD 7E 00      [19]  220 	ld	a,0 (iy)
   00F0 D6 03         [ 7]  221 	sub	a, #0x03
   00F2 20 0A         [12]  222 	jr	NZ,00103$
   00F4 FD 7E 01      [19]  223 	ld	a,1 (iy)
   00F7 B7            [ 4]  224 	or	a, a
   00F8 20 04         [12]  225 	jr	NZ,00103$
   00FA 3E 01         [ 7]  226 	ld	a,#0x01
   00FC 18 01         [12]  227 	jr	00104$
   00FE                     228 00103$:
   00FE AF            [ 4]  229 	xor	a,a
   00FF                     230 00104$:
   00FF E6 01         [ 7]  231 	and	a,#0x01
   0101 4F            [ 4]  232 	ld	c,a
   0102 7E            [ 7]  233 	ld	a,(hl)
   0103 E6 FE         [ 7]  234 	and	a,#0xfe
   0105 B1            [ 4]  235 	or	a,c
   0106 77            [ 7]  236 	ld	(hl),a
   0107 C9            [10]  237 	ret
                            238 ;usart.c:43: inline void usart_init(uint16_t baudrate, int parity, int stop_bits)
                            239 ;	---------------------------------
                            240 ; Function usart_init
                            241 ; ---------------------------------
   0108                     242 _usart_init::
                            243 ;usart.c:45: usart_set_baudrate(baudrate);
   0108 C1            [10]  244 	pop	bc
   0109 E1            [10]  245 	pop	hl
   010A E5            [11]  246 	push	hl
   010B C5            [11]  247 	push	bc
   010C E5            [11]  248 	push	hl
   010D CDr00r00      [17]  249 	call	_usart_set_baudrate
   0110 F1            [10]  250 	pop	af
                            251 ;usart.c:46: usart_set_parity(parity);
   0111 21 04 00      [10]  252 	ld	hl, #4
   0114 39            [11]  253 	add	hl, sp
   0115 4E            [ 7]  254 	ld	c, (hl)
   0116 23            [ 6]  255 	inc	hl
   0117 46            [ 7]  256 	ld	b, (hl)
   0118 C5            [11]  257 	push	bc
   0119 CDr34r00      [17]  258 	call	_usart_set_parity
   011C F1            [10]  259 	pop	af
                            260 ;usart.c:47: usart_set_stop_bits(stop_bits);
   011D 21 06 00      [10]  261 	ld	hl, #6
   0120 39            [11]  262 	add	hl, sp
   0121 4E            [ 7]  263 	ld	c, (hl)
   0122 23            [ 6]  264 	inc	hl
   0123 46            [ 7]  265 	ld	b, (hl)
   0124 C5            [11]  266 	push	bc
   0125 CDr88r00      [17]  267 	call	_usart_set_stop_bits
                            268 ;usart.c:48: usart_set_autoflow(USART_AUTOFLOW_OFF);
   0128 21 00 00      [10]  269 	ld	hl, #0x0000
   012B E3            [19]  270 	ex	(sp),hl
   012C CDrCEr00      [17]  271 	call	_usart_set_autoflow
   012F F1            [10]  272 	pop	af
   0130 C9            [10]  273 	ret
                            274 ;usart.c:51: void usart_transmit(uint8_t data)
                            275 ;	---------------------------------
                            276 ; Function usart_transmit
                            277 ; ---------------------------------
   0131                     278 _usart_transmit::
                            279 ;usart.c:53: _usart->buffer = data;
   0131 2Ar00r00      [16]  280 	ld	hl,(__usart)
   0134 FD 21 02 00   [14]  281 	ld	iy,#2
   0138 FD 39         [15]  282 	add	iy,sp
   013A FD 7E 00      [19]  283 	ld	a,0 (iy)
   013D 77            [ 7]  284 	ld	(hl),a
                            285 ;usart.c:54: while (_usart->LSR.transmitter_holder_empty == 0); // wait
   013E                     286 00101$:
   013E 2Ar00r00      [16]  287 	ld	hl,(__usart)
   0141 01 0D 00      [10]  288 	ld	bc,#0x000d
   0144 09            [11]  289 	add	hl,bc
   0145 7E            [ 7]  290 	ld	a,(hl)
   0146 07            [ 4]  291 	rlca
   0147 07            [ 4]  292 	rlca
   0148 07            [ 4]  293 	rlca
   0149 30 F3         [12]  294 	jr	NC,00101$
   014B C9            [10]  295 	ret
                            296 ;usart.c:57: uint8_t usart_receive()
                            297 ;	---------------------------------
                            298 ; Function usart_receive
                            299 ; ---------------------------------
   014C                     300 _usart_receive::
                            301 ;usart.c:59: return _usart->buffer;
   014C 2Ar00r00      [16]  302 	ld	hl,(__usart)
   014F 6E            [ 7]  303 	ld	l,(hl)
   0150 C9            [10]  304 	ret
                            305 ;usart.c:62: int usart_write(uint8_t *data, size_t size)
                            306 ;	---------------------------------
                            307 ; Function usart_write
                            308 ; ---------------------------------
   0151                     309 _usart_write::
   0151 DD E5         [15]  310 	push	ix
   0153 DD 21 00 00   [14]  311 	ld	ix,#0
   0157 DD 39         [15]  312 	add	ix,sp
   0159 F5            [11]  313 	push	af
                            314 ;usart.c:64: uint8_t *dp = data;
   015A DD 7E 04      [19]  315 	ld	a,4 (ix)
   015D DD 77 FE      [19]  316 	ld	-2 (ix),a
   0160 DD 7E 05      [19]  317 	ld	a,5 (ix)
   0163 DD 77 FF      [19]  318 	ld	-1 (ix),a
                            319 ;usart.c:66: while (size--) {
   0166 DD 4E 06      [19]  320 	ld	c,6 (ix)
   0169 DD 46 07      [19]  321 	ld	b,7 (ix)
   016C                     322 00104$:
   016C 59            [ 4]  323 	ld	e, c
   016D 50            [ 4]  324 	ld	d, b
   016E 0B            [ 6]  325 	dec	bc
   016F 7A            [ 4]  326 	ld	a,d
   0170 B3            [ 4]  327 	or	a,e
   0171 28 1E         [12]  328 	jr	Z,00106$
                            329 ;usart.c:67: _usart->buffer = *(dp++);
   0173 ED 5Br00r00   [20]  330 	ld	de,(__usart)
   0177 E1            [10]  331 	pop	hl
   0178 E5            [11]  332 	push	hl
   0179 7E            [ 7]  333 	ld	a,(hl)
   017A DD 34 FE      [23]  334 	inc	-2 (ix)
   017D 20 03         [12]  335 	jr	NZ,00126$
   017F DD 34 FF      [23]  336 	inc	-1 (ix)
   0182                     337 00126$:
   0182 12            [ 7]  338 	ld	(de),a
                            339 ;usart.c:68: while (_usart->LSR.transmitter_empty);
   0183                     340 00101$:
   0183 2Ar00r00      [16]  341 	ld	hl,(__usart)
   0186 11 0D 00      [10]  342 	ld	de,#0x000d
   0189 19            [11]  343 	add	hl,de
   018A 7E            [ 7]  344 	ld	a,(hl)
   018B 07            [ 4]  345 	rlca
   018C 07            [ 4]  346 	rlca
   018D 30 DD         [12]  347 	jr	NC,00104$
   018F 18 F2         [12]  348 	jr	00101$
   0191                     349 00106$:
                            350 ;usart.c:72: return size;
   0191 69            [ 4]  351 	ld	l, c
   0192 60            [ 4]  352 	ld	h, b
   0193 DD F9         [10]  353 	ld	sp, ix
   0195 DD E1         [14]  354 	pop	ix
   0197 C9            [10]  355 	ret
                            356 ;usart.c:75: int usart_read(uint8_t *buffer, size_t count)
                            357 ;	---------------------------------
                            358 ; Function usart_read
                            359 ; ---------------------------------
   0198                     360 _usart_read::
   0198 DD E5         [15]  361 	push	ix
   019A DD 21 00 00   [14]  362 	ld	ix,#0
   019E DD 39         [15]  363 	add	ix,sp
   01A0 21 FA FF      [10]  364 	ld	hl,#-6
   01A3 39            [11]  365 	add	hl,sp
   01A4 F9            [ 6]  366 	ld	sp,hl
                            367 ;usart.c:77: uint8_t *bp = buffer;
   01A5 DD 7E 04      [19]  368 	ld	a,4 (ix)
   01A8 DD 77 FC      [19]  369 	ld	-4 (ix),a
   01AB DD 7E 05      [19]  370 	ld	a,5 (ix)
   01AE DD 77 FD      [19]  371 	ld	-3 (ix),a
                            372 ;usart.c:80: while (count--) {
   01B1 DD 4E 06      [19]  373 	ld	c,6 (ix)
   01B4 DD 46 07      [19]  374 	ld	b,7 (ix)
   01B7 21 00 00      [10]  375 	ld	hl,#0x0000
   01BA E3            [19]  376 	ex	(sp), hl
   01BB                     377 00105$:
   01BB 59            [ 4]  378 	ld	e, c
   01BC 50            [ 4]  379 	ld	d, b
   01BD 0B            [ 6]  380 	dec	bc
   01BE 7A            [ 4]  381 	ld	a,d
   01BF B3            [ 4]  382 	or	a,e
   01C0 28 55         [12]  383 	jr	Z,00107$
                            384 ;usart.c:81: *(bp++) = _usart->buffer;
   01C2 2Ar00r00      [16]  385 	ld	hl,(__usart)
   01C5 5E            [ 7]  386 	ld	e,(hl)
   01C6 DD 6E FC      [19]  387 	ld	l,-4 (ix)
   01C9 DD 66 FD      [19]  388 	ld	h,-3 (ix)
   01CC 73            [ 7]  389 	ld	(hl),e
   01CD DD 34 FC      [23]  390 	inc	-4 (ix)
   01D0 20 03         [12]  391 	jr	NZ,00123$
   01D2 DD 34 FD      [23]  392 	inc	-3 (ix)
   01D5                     393 00123$:
   01D5 ED 5Br00r00   [20]  394 	ld	de,(__usart)
                            395 ;usart.c:83: if (_usart->LSR.framing_error || _usart->LSR.parity_error) {
   01D9 21 0D 00      [10]  396 	ld	hl,#0x000d
   01DC 19            [11]  397 	add	hl,de
   01DD DD 75 FE      [19]  398 	ld	-2 (ix),l
   01E0 DD 74 FF      [19]  399 	ld	-1 (ix),h
   01E3 DD 6E FE      [19]  400 	ld	l,-2 (ix)
   01E6 DD 66 FF      [19]  401 	ld	h,-1 (ix)
   01E9 7E            [ 7]  402 	ld	a,(hl)
   01EA 0F            [ 4]  403 	rrca
   01EB 0F            [ 4]  404 	rrca
   01EC 0F            [ 4]  405 	rrca
   01ED E6 01         [ 7]  406 	and	a,#0x01
   01EF 20 0D         [12]  407 	jr	NZ,00101$
   01F1 DD 6E FE      [19]  408 	ld	l,-2 (ix)
   01F4 DD 66 FF      [19]  409 	ld	h,-1 (ix)
   01F7 7E            [ 7]  410 	ld	a,(hl)
   01F8 0F            [ 4]  411 	rrca
   01F9 0F            [ 4]  412 	rrca
   01FA E6 01         [ 7]  413 	and	a,#0x01
   01FC 28 0F         [12]  414 	jr	Z,00102$
   01FE                     415 00101$:
                            416 ;usart.c:84: bp--; // delete last byte (?)
   01FE DD 6E FC      [19]  417 	ld	l,-4 (ix)
   0201 DD 66 FD      [19]  418 	ld	h,-3 (ix)
   0204 2B            [ 6]  419 	dec	hl
   0205 DD 75 FC      [19]  420 	ld	-4 (ix),l
   0208 DD 74 FD      [19]  421 	ld	-3 (ix),h
   020B 18 AE         [12]  422 	jr	00105$
   020D                     423 00102$:
                            424 ;usart.c:86: read_count++;
   020D DD 34 FA      [23]  425 	inc	-6 (ix)
   0210 20 A9         [12]  426 	jr	NZ,00105$
   0212 DD 34 FB      [23]  427 	inc	-5 (ix)
   0215 18 A4         [12]  428 	jr	00105$
   0217                     429 00107$:
                            430 ;usart.c:90: return read_count;
   0217 E1            [10]  431 	pop	hl
   0218 E5            [11]  432 	push	hl
   0219 DD F9         [10]  433 	ld	sp, ix
   021B DD E1         [14]  434 	pop	ix
   021D C9            [10]  435 	ret
                            436 	.area _CODE
                            437 	.area _INITIALIZER
   0000                     438 __xinit___usart:
   0000 00 40               439 	.dw #0x4000
                            440 	.area _CABS (ABS)
